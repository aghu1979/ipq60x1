name: OpenWrt Base System Build

on:
  workflow_call:
    inputs:
      chip:
        required: true
        type: string
      branch:
        required: true
        type: string

jobs:
  build-base:
    runs-on: ubuntu-22.04
    outputs:
      cache-key: ${{ steps.cache-key.outputs.key }}
      build-path: ${{ steps.cache-key.outputs.path }}
      cache-info: ${{ steps.cache-info.outputs.json }}
    steps:
      - name: 🛠️ 初始化环境
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: 📥 检出代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 🔍 检查目录结构
        run: |
          echo "📌 当前工作目录: $(pwd)"
          echo "📌 根目录内容:"
          ls -la
          echo ""
          echo "📌 检查.github目录:"
          ls -la .github/ 2>/dev/null || echo "❌ .github目录不存在"
          echo ""
          echo "📌 查找configs目录:"
          find . -name "configs" -type d 2>/dev/null
          echo ""
          echo "📌 查找scripts目录:"
          find . -name "scripts" -type d 2>/dev/null
          echo ""
          echo "📌 查找base配置文件:"
          find . -name "base_*.config" -type f 2>/dev/null
          echo ""
          echo "📋 输入参数:"
          echo "  - chip: '${{ inputs.chip }}'"
          echo "  - branch: '${{ inputs.branch }}'"

      - name: 🔑 生成缓存键
        id: cache-key
        run: |
          echo "📋 开始生成缓存键..."
          echo "  - chip: '${{ inputs.chip }}'"
          echo "  - branch: '${{ inputs.branch }}'"
          
          # 检查配置文件是否存在
          CHIP_CONFIG_FILE="base_${{ inputs.chip }}.config"
          BRANCH_CONFIG_FILE="base_${{ inputs.branch }}.config"
          
          echo "📋 查找配置文件:"
          echo "  - 芯片配置文件: $CHIP_CONFIG_FILE"
          echo "  - 分支配置文件: $BRANCH_CONFIG_FILE"
          
          # 查找芯片配置文件
          if [ -f "configs/$CHIP_CONFIG_FILE" ]; then
            CHIP_CONFIG="configs/$CHIP_CONFIG_FILE"
            echo "  ✅ 找到芯片配置: $CHIP_CONFIG"
          elif [ -f ".github/configs/$CHIP_CONFIG_FILE" ]; then
            CHIP_CONFIG=".github/configs/$CHIP_CONFIG_FILE"
            echo "  ✅ 找到芯片配置: $CHIP_CONFIG"
          else
            echo "  ❌ 找不到芯片配置文件: $CHIP_CONFIG_FILE"
            echo "📋 可用的芯片配置文件:"
            find . -name "base_*.config" -type f 2>/dev/null | sed 's/^/    /'
            exit 1
          fi
          
          # 查找分支配置文件
          if [ -f "configs/$BRANCH_CONFIG_FILE" ]; then
            BRANCH_CONFIG="configs/$BRANCH_CONFIG_FILE"
            echo "  ✅ 找到分支配置: $BRANCH_CONFIG"
          elif [ -f ".github/configs/$BRANCH_CONFIG_FILE" ]; then
            BRANCH_CONFIG=".github/configs/$BRANCH_CONFIG_FILE"
            echo "  ✅ 找到分支配置: $BRANCH_CONFIG"
          else
            echo "  ❌ 找不到分支配置文件: $BRANCH_CONFIG_FILE"
            echo "📋 可用的分支配置文件:"
            find . -name "base_*.config" -type f 2>/dev/null | grep "base_openwrt\|base_immwrt\|base_libwrt" | sed 's/^/    /'
            exit 1
          fi
          
          # 生成基于配置的缓存键
          CHIP_HASH=$(sha256sum "$CHIP_CONFIG" | cut -d' ' -f1)
          BRANCH_HASH=$(sha256sum "$BRANCH_CONFIG" | cut -d' ' -f1)
          CACHE_KEY="base-${{ inputs.chip }}-${{ inputs.branch }}-${CHIP_HASH:0:8}-${BRANCH_HASH:0:8}"
          BUILD_PATH="build-base-${{ inputs.chip }}-${{ inputs.branch }}"
          
          echo "key=$CACHE_KEY" >> $GITHUB_OUTPUT
          echo "path=$BUILD_PATH" >> $GITHUB_OUTPUT
          echo "chip-config=$CHIP_CONFIG" >> $GITHUB_OUTPUT
          echo "branch-config=$BRANCH_CONFIG" >> $GITHUB_OUTPUT
          echo "✅ 缓存键生成完成: $CACHE_KEY"

      - name: 📋 生成缓存信息
        id: cache-info
        run: |
          # 生成包含所有缓存信息的JSON
          CACHE_INFO=$(jq -n \
            --arg branch "${{ inputs.branch }}" \
            --arg key "${{ steps.cache-key.outputs.key }}" \
            --arg path "${{ steps.cache-key.outputs.path }}" \
            '{
              ($branch): {
                "cache-key": $key,
                "build-path": $path
              }
            }')
          echo "json=$CACHE_INFO" >> $GITHUB_OUTPUT
          echo "📋 缓存信息: $CACHE_INFO"

      - name: 📦 恢复基础环境缓存
        id: cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.cache-key.outputs.path }}
          key: ${{ steps.cache-key.outputs.key }}
          restore-keys: |
            base-${{ inputs.chip }}-${{ inputs.branch }}-

      - name: 🌱 准备基础环境
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          echo "🔧 准备基础编译环境..."
          echo "📌 当前工作目录: $(pwd)"
          echo "📌 芯片: ${{ inputs.chip }}"
          echo "📌 分支: ${{ inputs.branch }}"
          echo "📌 芯片配置文件: ${{ steps.cache-key.outputs.chip-config }}"
          echo "📌 分支配置文件: ${{ steps.cache-key.outputs.branch-config }}"
          
          # 创建构建目录
          mkdir -p ${{ steps.cache-key.outputs.path }}
          
          # 设置源码仓库URL和分支 - 使用正确的仓库地址
          case "${{ inputs.branch }}" in
            "openwrt")
              REPO_URL="https://github.com/laipeng668/openwrt.git"
              REPO_BRANCH="master"
              ;;
            "immwrt")
              REPO_URL="https://github.com/laipeng668/immortalwrt.git"
              REPO_BRANCH="master"
              ;;
            "libwrt")
              REPO_URL="https://github.com/laipeng668/openwrt-6.x.git"
              REPO_BRANCH="k6.12-nss"
              ;;
            *)
              echo "❌ 不支持的分支: ${{ inputs.branch }}"
              echo "💡 支持的分支: openwrt, immwrt, libwrt"
              exit 1
              ;;
          esac
          
          echo "🔽 克隆源码: $REPO_URL"
          echo "📋 使用分支: $REPO_BRANCH"
          
          # 克隆指定分支
          git clone --depth=1 -b $REPO_BRANCH $REPO_URL openwrt-src
          
          # 进入源码目录
          cd openwrt-src
          echo "📌 进入源码目录: $(pwd)"
          echo "📌 当前分支:"
          git branch
          echo "📌 上级目录内容:"
          ls -la ../
          
          # 修正配置文件路径（相对于openwrt-src目录）
          CHIP_CONFIG_REL="../${{ steps.cache-key.outputs.chip-config }}"
          BRANCH_CONFIG_REL="../${{ steps.cache-key.outputs.branch-config }}"
          
          echo "📋 相对路径:"
          echo "  - 芯片配置: $CHIP_CONFIG_REL"
          echo "  - 分支配置: $BRANCH_CONFIG_REL"
          
          # 检查文件是否存在
          if [ ! -f "$CHIP_CONFIG_REL" ]; then
            echo "❌ 芯片配置文件不存在: $CHIP_CONFIG_REL"
            echo "📋 上级目录中的configs内容:"
            ls -la ../configs/ 2>/dev/null || echo "configs目录不存在"
            echo "📋 上级目录中的.github/configs内容:"
            ls -la ../.github/configs/ 2>/dev/null || echo ".github/configs目录不存在"
            exit 1
          fi
          
          if [ ! -f "$BRANCH_CONFIG_REL" ]; then
            echo "❌ 分支配置文件不存在: $BRANCH_CONFIG_REL"
            exit 1
          fi
          
          # 保存芯片配置（用于对比）
          echo "📋 保存芯片配置..."
          cp "$CHIP_CONFIG_REL" .config.chip
          echo "✅ 已保存芯片配置"
          
          # 应用芯片配置
          cp "$CHIP_CONFIG_REL" .config
          echo "✅ 已应用芯片配置"
          
          # 保存分支配置（用于对比）
          cp "$BRANCH_CONFIG_REL" .config.branch
          echo "✅ 已保存分支配置"
          
          # 追加分支配置
          cat "$BRANCH_CONFIG_REL" >> .config
          echo "✅ 已应用分支配置"
          
          # 第一次 make defconfig - 补全基础配置的依赖
          echo ""
          echo "🔧 第一次 make defconfig - 补全基础配置依赖..."
          make defconfig
          echo "📋 基础配置项数: $(grep -c '^CONFIG_' .config)"
          
          # 复制脚本文件
          if [ -d "../scripts" ]; then
            SCRIPT_DIR="../scripts"
          elif [ -d "../.github/scripts" ]; then
            SCRIPT_DIR="../.github/scripts"
          else
            echo "❌ 找不到scripts目录"
            echo "📋 上级目录内容:"
            ls -la ../
            exit 1
          fi
          
          echo "📋 使用脚本目录: $SCRIPT_DIR"
          cp "$SCRIPT_DIR/diy.sh" ./
          cp "$SCRIPT_DIR/repo.sh" ./
          cp "$SCRIPT_DIR/package-check.sh" ./
          cp "$SCRIPT_DIR/compare-packages.sh" ./
          chmod +x diy.sh repo.sh package-check.sh compare-packages.sh
          
          # 第一次LUCI软件包检查
          echo ""
          echo "🔍 ==================== 第一次LUCI软件包检查 ===================="
          # 执行检查（不自动修复）
          echo "🔍 执行package-check.sh脚本..."
          if ./package-check.sh .config "基础系统-初步检查" false; then
            echo "✅ 初步检查通过"
          else
            echo "⚠️ 初步检查发现问题，将在feeds更新后修复"
          fi
          
          # 第一阶段：对比芯片配置和合并后的配置
          echo ""
          echo "🔍 ==================== 基础系统配置对比 ===================="
          echo "🔍 执行compare-packages.sh脚本..."
          if ./compare-packages.sh .config.chip .config "基础系统"; then
            echo "✅ 配置对比完成"
          else
            echo "❌ 配置对比失败"
          fi
          
          # 执行初始化脚本
          echo ""
          echo "🔧 执行系统初始化..."
          ./diy.sh
          
          echo "📦 添加第三方软件源..."
          ./repo.sh
          
          # 更新feeds
          echo "🔄 更新软件包索引..."
          ./scripts/feeds update -a
          ./scripts/feeds install -a
          
          # 第二次 make defconfig - 补全feeds更新后的配置
          echo ""
          echo "🔧 第二次 make defconfig - 补全feeds更新后的配置..."
          make defconfig
          echo "📋 feeds更新后配置项数: $(grep -c '^CONFIG_' .config)"
          
          # 第二次LUCI软件包检查和自动修复
          echo ""
          echo "🔍 ==================== 第二次LUCI软件包检查（自动修复） ===================="
          echo "🔍 执行package-check.sh脚本..."
          if ./package-check.sh .config "基础系统-最终检查" true; then
            echo "✅ 所有LUCI软件包检查通过！"
          else
            echo "❌ LUCI软件包检查失败，基础系统编译将停止"
            exit 1
          fi
          
          # 准备编译环境
          echo "🔨 准备编译工具链..."
          make -j$(nproc) IGNORE_ERRORS=1 download
          make -j$(nproc) IGNORE_ERRORS=1 tools/compile
          make -j$(nproc) IGNORE_ERRORS=1 toolchain/compile
          
          # 保存报告到上级目录
          echo ""
          echo "📋 保存报告文件..."
          echo "📋 检查生成的报告文件..."
          ls -la *.md 2>/dev/null || echo "没有找到报告文件"
          
          # 复制所有.md文件到上级目录
          for report in *.md; do
            if [ -f "$report" ]; then
              cp "$report" "../luci-packages-基础系统-${{ inputs.branch }}.md"
              echo "✅ 已保存报告: $report"
            fi
          done
          
          # 返回上级目录
          cd ..
          
          # 打包基础环境
          echo "📦 打包基础环境..."
          tar -czf ${{ steps.cache-key.outputs.path }}/base.tar.gz -C openwrt-src .
          echo "✅ 基础环境准备完成"

      - name: 📋 处理缓存命中的报告
        if: steps.cache.outputs.cache-hit == 'true'
        run: |
          echo "📋 缓存命中，从缓存中提取报告文件..."
          
          # 解压缓存中的报告文件
          BUILD_PATH="${{ steps.cache-key.outputs.path }}"
          echo "📌 构建路径: $BUILD_PATH"
          
          if [ -f "$BUILD_PATH/base.tar.gz" ]; then
            echo "📦 解压缓存文件..."
            mkdir -p temp-extract
            tar -xzf "$BUILD_PATH/base.tar.gz" -C temp-extract
            
            # 查找并复制报告文件
            echo "📋 查找报告文件..."
            find temp-extract -name "*.md" -type f -exec echo "找到报告: {}" \;
            
            # 复制所有.md文件到当前目录
            find temp-extract -name "*.md" -type f -exec cp {} . \;
            
            # 复制到上级目录 - 修复引号问题
            for report in 基础系统-最终检查.md 基础系统-初步检查.md 基础系统.md; do
              if [ -f "temp-extract/$report" ]; then
                cp "temp-extract/$report" "../luci-packages-基础系统-${{ inputs.branch }}.md"
                echo "✅ 已提取报告: $report"
              fi
            done
            
            # 清理临时目录
            rm -rf temp-extract
            
            # 检查报告文件
            echo "📋 检查报告文件..."
            ls -la *.md 2>/dev/null || echo "没有找到报告文件"
          else
            echo "❌ 缓存中没有找到base.tar.gz文件"
            echo "📋 检查构建路径内容:"
            ls -la "$BUILD_PATH" 2>/dev/null || echo "构建路径不存在"
          fi

      - name: 📤 上传基础系统报告
        if: always()
        run: |
          echo "📋 检查报告文件..."
          ls -la *.md 2>/dev/null || echo "没有找到报告文件"
          
          # 创建临时目录用于上传
          mkdir -p upload-reports
          
          # 复制所有可能的报告文件 - 修复文件名匹配问题
          for report in luci-packages-基础系统-${{ inputs.branch }}.md 基础系统-初步检查.md 基础系统.md luci-packages-基础系统.md; do
            if [ -f "$report" ]; then
              cp "$report" upload-reports/
              echo "✅ 找到报告文件: $report"
            else
              echo "⚠️ 报告文件不存在: $report"
            fi
          done
          
          # 显示上传目录内容
          echo "📋 上传目录内容:"
          ls -la upload-reports/

      - name: 📤 上传基础系统报告
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: base-report-${{ inputs.branch }}-${{ github.run_id }}
          path: upload-reports/
          retention-days: 7
          if-no-files-found: warn
